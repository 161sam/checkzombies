#!/bin/bash
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêSTART‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# checkzombies - Zombie-Prozess-√úberwachung & Cleanup
# Features: Logging, systemd-Check, sichere Signal-Eskalation, Batch-Modus
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

set -euo pipefail
IFS=$'\n\t'

VERSION="2.0"
LOGFILE="${HOME}/checkzombies.log"
WATCH_INTERVAL_DEFAULT=10
WAIT_SECONDS=3

MODE=""
FORCE=0
WATCH_INTERVAL=$WATCH_INTERVAL_DEFAULT

action_log() {
    local now
    now=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$now] $*" | tee -a "$LOGFILE" >&2 || true
}

show_version() {
    echo "checkzombies ${VERSION}"
}

short_usage() {
    echo "Usage: checkzombies [--list|--auto|--watch] [--force]" >&2
    echo "Try 'checkzombies --help' for more information." >&2
}

show_help() {
    cat <<'HELP'
checkzombies - Zombie-Prozess-√úberwachung & Cleanup

Usage:
  checkzombies [OPTIONS]

Modi (genau einer):
  -l, --list       Nur Zombies auflisten (keine Interaktion)
  -a, --auto       Automatische Bereinigung
  -w, --watch      Kontinuierliche √úberwachung (alle 10s)

Optionen:
  -f, --force      Erlaubt KILL nach TERM-Timeout (nicht mit --list)
  -h, --help       Hilfe anzeigen
  -v, --version    Version anzeigen
  --               Ende der Optionen

Hinweis: Ohne Modus wird bei TTY das interaktive Men√º ge√∂ffnet.
Bei non-TTY wird automatisch --list verwendet.

Exit-Codes: 0 = keine Zombies/erfolgreich bereinigt, 1 = Fehler,
2 = Zombies gefunden, aber nicht bereinigt.
HELP
}

set_mode() {
    local requested=$1
    if [[ -n "$MODE" ]]; then
        echo "Error: only one mode can be selected." >&2
        short_usage
        exit 1
    fi
    MODE=$requested
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -l|--list)
                set_mode "list"
                ;;
            -a|--auto)
                set_mode "auto"
                ;;
            -w|--watch)
                set_mode "watch"
                ;;
            -f|--force)
                FORCE=1
                ;;
            --)
                shift
                break
                ;;
            -* )
                echo "Error: unknown option: $1" >&2
                short_usage
                exit 1
                ;;
            *)
                echo "Error: unexpected argument: $1" >&2
                short_usage
                exit 1
                ;;
        esac
        shift
    done

    if [[ -z "$MODE" ]]; then
        if [[ -t 0 && -t 1 ]]; then
            MODE="interactive"
        else
            MODE="list"
            echo "Hinweis: kein TTY erkannt; wechsle zu --list." >&2
        fi
    fi

    if [[ "$MODE" == "list" && "$FORCE" -eq 1 ]]; then
        echo "Error: --force is not valid with --list." >&2
        short_usage
        exit 1
    fi

    if [[ "$MODE" == "watch" && "$FORCE" -eq 1 ]]; then
        echo "Hinweis: --force hat im Watch-Modus keine Wirkung." >&2
    fi
}

find_zombies() {
    ps -eo pid=,ppid=,stat=,comm= | awk '$3 ~ /^Z/ {print $1","$2","$3","$4}'
}

is_numeric() {
    [[ "$1" =~ ^[0-9]+$ ]]
}

get_service() {
    local ppid=$1
    local status service

    if ! command -v systemctl >/dev/null 2>&1; then
        echo "none"
        return 0
    fi

    status=$(systemctl status "$ppid" 2>/dev/null || true)
    if [[ -z "$status" ]]; then
        echo "none"
        return 0
    fi

    service=$(awk '/Main PID/ {print $3; exit}' <<<"$status")
    echo "${service:-none}"
}

declare -a ZOMBIES=()

collect_zombies() {
    ZOMBIES=()
    while IFS=, read -r pid ppid state cmd; do
        is_numeric "$pid" || continue
        is_numeric "$ppid" || continue
        [[ "$pid" -gt 1 ]] || continue
        [[ "$pid" -ne "$ppid" ]] || continue
        local service
        service=$(get_service "$ppid")
        ZOMBIES+=("$pid,$ppid,$state,$cmd,$service")
    done < <(find_zombies)
}

declare -a PARENTS=()
declare -A PARENT_SERVICE=()

collect_parents() {
    PARENTS=()
    PARENT_SERVICE=()

    local entry pid ppid state cmd service
    for entry in "${ZOMBIES[@]}"; do
        IFS=, read -r pid ppid state cmd service <<<"$entry"
        if [[ -z "${PARENT_SERVICE[$ppid]:-}" ]]; then
            PARENT_SERVICE["$ppid"]=$service
            PARENTS+=("$ppid")
        fi
    done
}

print_zombies() {
    echo "PID    PPID   STAT  COMMAND                  SERVICE"
    for entry in "${ZOMBIES[@]}"; do
        IFS=, read -r pid ppid state cmd service <<<"$entry"
        printf "%-6s %-6s %-5s %-20s %s\n" "$pid" "$ppid" "$state" "$cmd" "$service"
    done
}

parent_has_zombies() {
    local ppid=$1
    local entry_pid entry_ppid entry_state entry_cmd

    while IFS=, read -r entry_pid entry_ppid entry_state entry_cmd; do
        if [[ "$entry_ppid" == "$ppid" ]]; then
            return 0
        fi
    done < <(find_zombies)

    return 1
}

wait_for_exit() {
    local ppid=$1
    local interval=0.5
    local max_checks=$((WAIT_SECONDS * 2))
    local i

    for ((i = 0; i < max_checks; i++)); do
        if ! kill -0 "$ppid" 2>/dev/null; then
            return 0
        fi
        sleep "$interval"
    done

    return 1
}

terminate_parent() {
    local ppid=$1
    local service=$2

    if ! is_numeric "$ppid"; then
        action_log "SKIP: PPID not numeric ($ppid)"
        return 1
    fi

    if [[ "$ppid" -lt 2 ]]; then
        if [[ "$ppid" -eq 1 ]]; then
            action_log "SKIP: PPID=1"
        else
            action_log "SKIP: PPID<2 ($ppid)"
        fi
        return 1
    fi

    if ! kill -0 "$ppid" 2>/dev/null; then
        action_log "SKIP: Parent already exited (PPID=$ppid)"
        return 1
    fi

    if kill -TERM "$ppid" 2>/dev/null; then
        action_log "TERM sent to PPID=$ppid"
    else
        if kill -0 "$ppid" 2>/dev/null; then
            action_log "FAIL: unable to send TERM to PPID=$ppid"
            return 1
        fi
        action_log "SKIP: Parent already exited (PPID=$ppid)"
        return 1
    fi

    if wait_for_exit "$ppid"; then
        action_log "OK: Parent terminated (PPID=$ppid)"
    else
        action_log "WAIT: timeout reached (PPID=$ppid)"
        if [[ "$FORCE" -eq 1 ]]; then
            if kill -KILL "$ppid" 2>/dev/null; then
                action_log "KILL sent to PPID=$ppid"
            else
                if kill -0 "$ppid" 2>/dev/null; then
                    action_log "FAIL: unable to send KILL to PPID=$ppid"
                    return 1
                fi
                action_log "SKIP: Parent already exited (PPID=$ppid)"
                return 1
            fi

            if kill -0 "$ppid" 2>/dev/null; then
                action_log "FAIL: Parent still alive (PPID=$ppid)"
                return 1
            fi
            action_log "OK: Parent terminated (PPID=$ppid)"
        else
            action_log "FAIL: Parent still alive (PPID=$ppid)"
            return 1
        fi
    fi

    if parent_has_zombies "$ppid"; then
        action_log "FAIL: Parent still has zombies (PPID=$ppid)"
        return 1
    fi

    if [[ "$service" != "none" ]]; then
        if systemctl restart "$service" 2>/dev/null; then
            action_log "Service restarted ($service)"
        else
            action_log "WARN: Service restart failed ($service)"
        fi
    fi

    return 0
}

process_parents() {
    local failures=0
    local ppid service

    for ppid in "${PARENTS[@]}"; do
        service=${PARENT_SERVICE[$ppid]-}
        action_log "Handle parent PPID=$ppid"
        if ! terminate_parent "$ppid" "$service"; then
            failures=$((failures + 1))
        fi
    done

    if [[ "$failures" -gt 0 ]]; then
        return 2
    fi

    return 0
}

cmd_list() {
    collect_zombies

    local count=${#ZOMBIES[@]}
    if [[ "$count" -eq 0 ]]; then
        echo "‚úì Keine Zombie-Prozesse aktiv"
        return 0
    fi

    action_log "=== $count Zombie-Prozesse gefunden ==="
    print_zombies
    echo

    return 2
}

cmd_auto() {
    collect_zombies
    collect_parents

    local count=${#ZOMBIES[@]}
    if [[ "$count" -eq 0 ]]; then
        echo "‚úì Keine Zombie-Prozesse aktiv"
        return 0
    fi

    action_log "=== $count Zombie-Prozesse gefunden ==="
    print_zombies
    echo

    process_parents
}

cmd_interactive() {
    collect_zombies
    collect_parents

    local count=${#ZOMBIES[@]}
    if [[ "$count" -eq 0 ]]; then
        echo "‚úì Keine Zombie-Prozesse aktiv"
        return 0
    fi

    action_log "=== $count Zombie-Prozesse gefunden ==="
    print_zombies
    echo

    echo "Optionen:"
    echo "  a) Alle Parents terminieren"
    echo "  i) Einzeln bearbeiten"
    echo "  q) Beenden"

    local choice
    if ! read -r choice; then
        echo "‚ùå Keine Eingabe erhalten"
        return 1
    fi

    case "${choice,,}" in
        a)
            process_parents
            return $?
            ;;
        i)
            local index=1
            for entry in "${ZOMBIES[@]}"; do
                IFS=, read -r pid ppid _state cmd service <<<"$entry"
                echo "$index: PID $pid <- PPID $ppid ($cmd)"
                index=$((index + 1))
            done
            local num
            if ! read -r num; then
                echo "‚ùå Keine Auswahl erhalten"
                return 1
            fi
            if [[ ! "$num" =~ ^[0-9]+$ || "$num" -lt 1 || "$num" -gt "$count" ]]; then
                echo "‚ùå Ung√ºltig"
                return 1
            fi
            local zombie_line=${ZOMBIES[$((num - 1))]}
            IFS=, read -r pid ppid _state cmd service <<<"$zombie_line"
            echo "üîß Zombie $pid ‚Üí kill $ppid"
            if [[ "$FORCE" -ne 1 ]]; then
                local confirm
                echo "Bitte best√§tigen (y/N):"
                if ! read -r confirm; then
                    echo "‚ùå Keine Best√§tigung erhalten"
                    return 1
                fi
                if [[ ! "$confirm" =~ [Yy] ]]; then
                    echo "üëã Abgebrochen ($count Zombies)"
                    return 2
                fi
            fi
            if ! terminate_parent "$ppid" "$service"; then
                return 2
            fi
            return 0
            ;;
        q)
            echo "üëã Abgebrochen ($count Zombies)"
            return 2
            ;;
        *)
            echo "‚ùå Ung√ºltig"
            return 1
            ;;
    esac
}

cmd_watch() {
    trap 'echo; echo "√úberwachung beendet"; exit 0' INT TERM

    while true; do
        if cmd_list; then
            :
        else
            local status=$?
            if [[ "$status" -eq 1 ]]; then
                return 1
            fi
        fi
        sleep "$WATCH_INTERVAL"
    done
}

main() {
    parse_args "$@"

    case "$MODE" in
        list)
            cmd_list
            ;;
        auto)
            cmd_auto
            ;;
        watch)
            cmd_watch
            ;;
        interactive)
            cmd_interactive
            ;;
        *)
            echo "Error: unknown mode $MODE" >&2
            return 1
            ;;
    esac
}

main "$@"
