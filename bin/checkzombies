#!/bin/bash
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêSTART‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# checkzombies - Zombie-Prozess-√úberwachung & Cleanup
# Features: Logging, systemd-Check, sichere Signal-Eskalation, Batch-Modus
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

set -euo pipefail
IFS=$'\n\t'

VERSION="2.0"
LOG_FILE_DEFAULT="${HOME}/checkzombies.log"
LOG_FILE="${CHECKZOMBIES_LOG_FILE:-$LOG_FILE_DEFAULT}"
LOG_LEVEL_DEFAULT="INFO"
LOG_LEVEL="${CHECKZOMBIES_LOG_LEVEL:-$LOG_LEVEL_DEFAULT}"
LOG_SYSLOG=0
if [[ "${CHECKZOMBIES_LOG_SYSLOG:-}" == "1" ]]; then
    LOG_SYSLOG=1
fi
LOG_TO_FILE=1
LOG_FILE_WRITE_FAILED=0
WATCH_INTERVAL_DEFAULT=10
WAIT_SECONDS=3

MODE=""
FORCE=0
WATCH_INTERVAL=$WATCH_INTERVAL_DEFAULT
NO_UNICODE=0
OUTPUT_TTY=0
UNICODE=0

OK_SYMBOL="[OK]"
WARN_SYMBOL="[!]"
INFO_SYMBOL="[i]"
FAIL_SYMBOL="[ERR]"
ZOMBIE_SYMBOL="[Z]"

normalize_log_level() {
    local level=${1^^}
    case "$level" in
        DEBUG|INFO|WARN|ERROR)
            echo "$level"
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

log_level_num() {
    case "$1" in
        DEBUG) echo 0 ;;
        INFO) echo 1 ;;
        WARN) echo 2 ;;
        ERROR) echo 3 ;;
        *) return 1 ;;
    esac
}

log_should_emit() {
    local level=$1
    local level_num threshold
    level_num=$(log_level_num "$level") || return 1
    threshold=$(log_level_num "$LOG_LEVEL") || return 1
    [[ "$level_num" -ge "$threshold" ]]
}

log_emit() {
    local level=$1
    shift
    local msg=$1
    shift
    log_should_emit "$level" || return 0
    local now
    now=$(date '+%Y-%m-%d %H:%M:%S')
    local line
    line="[$now] level=$level msg=\"$msg\""
    if [[ $# -gt 0 ]]; then
        line="$line $*"
    fi

    if [[ "$LOG_TO_FILE" -eq 1 ]]; then
        if ! printf '%s\n' "$line" >> "$LOG_FILE" 2>/dev/null; then
            LOG_TO_FILE=0
            if [[ "$LOG_FILE_WRITE_FAILED" -eq 0 ]]; then
                LOG_FILE_WRITE_FAILED=1
                printf '[%s] level=WARN msg="log file not writable, falling back to stderr only" path="%s"\n' \
                    "$now" "$LOG_FILE" >&2
            fi
        fi
    fi

    if [[ "$LOG_SYSLOG" -eq 1 ]]; then
        logger -t checkzombies -- "$line" 2>/dev/null || true
    fi

    printf '%s\n' "$line" >&2
}

log_debug() {
    log_emit "DEBUG" "$@"
}

log_info() {
    log_emit "INFO" "$@"
}

log_warn() {
    log_emit "WARN" "$@"
}

log_error() {
    log_emit "ERROR" "$@"
}

log_init() {
    local normalized
    if ! normalized=$(normalize_log_level "$LOG_LEVEL"); then
        printf '[%s] level=WARN msg="invalid log level, defaulting to INFO" value="%s"\n' \
            "$(date '+%Y-%m-%d %H:%M:%S')" "$LOG_LEVEL" >&2
        LOG_LEVEL="INFO"
    else
        LOG_LEVEL=$normalized
    fi

    if [[ "$LOG_TO_FILE" -eq 1 ]]; then
        if [[ -z "$LOG_FILE" ]]; then
            LOG_TO_FILE=0
            printf '[%s] level=WARN msg="log file path empty, disabling file logging"\n' \
                "$(date '+%Y-%m-%d %H:%M:%S')" >&2
        elif ! { : >> "$LOG_FILE"; } 2>/dev/null; then
            LOG_TO_FILE=0
            printf '[%s] level=WARN msg="log file not writable, falling back to stderr" path="%s"\n' \
                "$(date '+%Y-%m-%d %H:%M:%S')" "$LOG_FILE" >&2
        fi
    fi

    if [[ "$LOG_SYSLOG" -eq 1 ]]; then
        if ! command -v logger >/dev/null 2>&1; then
            LOG_SYSLOG=0
            printf '[%s] level=WARN msg="logger not found, disabling syslog logging"\n' \
                "$(date '+%Y-%m-%d %H:%M:%S')" >&2
        fi
    fi
}

show_version() {
    echo "checkzombies ${VERSION}"
}

short_usage() {
    echo "Usage: checkzombies [--list|--auto|--watch] [--force]" >&2
    echo "Try 'checkzombies --help' for more information." >&2
}

show_help() {
    cat <<'HELP'
checkzombies - Zombie-Prozess-√úberwachung & Cleanup

Usage:
  checkzombies [OPTIONS]

Modi (genau einer):
  -l, --list       Nur Zombies auflisten (keine Interaktion)
  -a, --auto       Automatische Bereinigung
  -w, --watch      Kontinuierliche √úberwachung (alle 10s)

Optionen:
  -f, --force      Erlaubt KILL nach TERM-Timeout (nicht mit --list)
  --no-unicode     Erzwingt ASCII-Ausgabe (keine Unicode-Symbole)
  --log-file PATH  Logdatei setzen (Default: $HOME/checkzombies.log)
  --no-log-file    Datei-Logging deaktivieren
  --log-syslog     Zus√§tzlich in syslog/journald loggen (via logger)
  --log-level LVL  Log-Level (DEBUG, INFO, WARN, ERROR)
  -h, --help       Hilfe anzeigen
  -v, --version    Version anzeigen
  --               Ende der Optionen

Hinweis: Ohne Modus wird bei TTY das interaktive Men√º ge√∂ffnet.
Bei non-TTY wird automatisch --list verwendet. Ausgabe ist dann ASCII,
ohne Header und ohne interaktive Prompts.

Exit-Codes: 0 = keine Zombies/erfolgreich bereinigt, 1 = Fehler,
2 = Zombies gefunden, aber nicht bereinigt.

Umgebungsvariablen:
  CHECKZOMBIES_LOG_FILE    Default-Logdatei √ºberschreiben
  CHECKZOMBIES_LOG_LEVEL   Default-Log-Level setzen
  CHECKZOMBIES_LOG_SYSLOG  Syslog-Logging aktivieren (1=ja)
HELP
}

set_mode() {
    local requested=$1
    if [[ -n "$MODE" ]]; then
        echo "Error: only one mode can be selected." >&2
        short_usage
        exit 1
    fi
    MODE=$requested
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -l|--list)
                set_mode "list"
                ;;
            -a|--auto)
                set_mode "auto"
                ;;
            -w|--watch)
                set_mode "watch"
                ;;
            -f|--force)
                FORCE=1
                ;;
            --no-unicode|--ascii)
                NO_UNICODE=1
                ;;
            --log-file)
                shift
                if [[ $# -eq 0 || -z "$1" ]]; then
                    echo "Error: --log-file requires a path argument." >&2
                    short_usage
                    exit 1
                fi
                LOG_FILE=$1
                LOG_TO_FILE=1
                ;;
            --no-log-file)
                LOG_TO_FILE=0
                ;;
            --log-syslog)
                LOG_SYSLOG=1
                ;;
            --log-level)
                shift
                if [[ $# -eq 0 || -z "$1" ]]; then
                    echo "Error: --log-level requires a value." >&2
                    short_usage
                    exit 1
                fi
                LOG_LEVEL=$1
                ;;
            --)
                shift
                break
                ;;
            -* )
                echo "Error: unknown option: $1" >&2
                short_usage
                exit 1
                ;;
            *)
                echo "Error: unexpected argument: $1" >&2
                short_usage
                exit 1
                ;;
        esac
        shift
    done

    if [[ -z "$MODE" ]]; then
        if [[ -t 0 && -t 1 ]]; then
            MODE="interactive"
        else
            MODE="list"
            echo "Hinweis: kein TTY erkannt; wechsle zu --list." >&2
        fi
    fi

    if [[ "$MODE" == "list" && "$FORCE" -eq 1 ]]; then
        echo "Error: --force is not valid with --list." >&2
        short_usage
        exit 1
    fi

    if [[ "$MODE" == "watch" && "$FORCE" -eq 1 ]]; then
        echo "Hinweis: --force hat im Watch-Modus keine Wirkung." >&2
    fi
}

setup_output_mode() {
    local locale_setting
    OUTPUT_TTY=0
    if [[ -t 1 ]]; then
        OUTPUT_TTY=1
    fi

    UNICODE=0
    if [[ "$NO_UNICODE" -eq 1 ]]; then
        UNICODE=0
    elif [[ "$OUTPUT_TTY" -eq 0 ]]; then
        UNICODE=0
    elif [[ "${TERM:-}" == "dumb" ]]; then
        UNICODE=0
    else
        locale_setting="${LC_ALL:-${LANG:-}}"
        if [[ "$locale_setting" == *"UTF-8"* || "$locale_setting" == *"utf8"* ]]; then
            UNICODE=1
        fi
    fi

    if [[ "$UNICODE" -eq 1 ]]; then
        OK_SYMBOL="‚úì"
        WARN_SYMBOL="‚ö†"
        INFO_SYMBOL="‚Ñπ"
        FAIL_SYMBOL="‚úñ"
        ZOMBIE_SYMBOL="üßü"
    else
        OK_SYMBOL="[OK]"
        WARN_SYMBOL="[!]"
        INFO_SYMBOL="[i]"
        FAIL_SYMBOL="[ERR]"
        ZOMBIE_SYMBOL="[Z]"
    fi
}

find_zombies() {
    ps -eo pid=,ppid=,stat=,comm= | awk '$3 ~ /^Z/ {print $1","$2","$3","$4}'
}

is_numeric() {
    [[ "$1" =~ ^[0-9]+$ ]]
}

get_service() {
    local ppid=$1
    local status service

    if ! command -v systemctl >/dev/null 2>&1; then
        echo "none"
        return 0
    fi

    status=$(systemctl status "$ppid" 2>/dev/null || true)
    if [[ -z "$status" ]]; then
        echo "none"
        return 0
    fi

    service=$(awk '/Main PID/ {print $3; exit}' <<<"$status")
    echo "${service:-none}"
}

declare -a ZOMBIES=()

collect_zombies() {
    ZOMBIES=()
    while IFS=, read -r pid ppid state cmd; do
        is_numeric "$pid" || continue
        is_numeric "$ppid" || continue
        [[ "$pid" -gt 1 ]] || continue
        [[ "$pid" -ne "$ppid" ]] || continue
        local service
        service=$(get_service "$ppid")
        ZOMBIES+=("$pid,$ppid,$state,$cmd,$service")
    done < <(find_zombies)
}

declare -a PARENTS=()
declare -A PARENT_SERVICE=()

collect_parents() {
    PARENTS=()
    PARENT_SERVICE=()

    local entry pid ppid state cmd service
    for entry in "${ZOMBIES[@]}"; do
        IFS=, read -r pid ppid state cmd service <<<"$entry"
        if [[ -z "${PARENT_SERVICE[$ppid]:-}" ]]; then
            PARENT_SERVICE["$ppid"]=$service
            PARENTS+=("$ppid")
        fi
    done
}

print_zombies() {
    if [[ "$OUTPUT_TTY" -eq 1 ]]; then
        echo "PID    PPID   STAT  COMMAND                  SERVICE"
        for entry in "${ZOMBIES[@]}"; do
            IFS=, read -r pid ppid state cmd service <<<"$entry"
            printf "%-6s %-6s %-5s %-20s %s\n" "$pid" "$ppid" "$state" "$cmd" "$service"
        done
    else
        for entry in "${ZOMBIES[@]}"; do
            IFS=, read -r pid ppid state cmd service <<<"$entry"
            printf "%s\t%s\t%s\t%s\t%s\n" "$pid" "$ppid" "$state" "$cmd" "$service"
        done
    fi
}

parent_has_zombies() {
    local ppid=$1

    while IFS=, read -r _ entry_ppid _ _; do
        if [[ "$entry_ppid" == "$ppid" ]]; then
            return 0
        fi
    done < <(find_zombies)

    return 1
}

wait_for_exit() {
    local ppid=$1
    local interval=0.5
    local max_checks=$((WAIT_SECONDS * 2))
    local i

    for ((i = 0; i < max_checks; i++)); do
        if ! kill -0 "$ppid" 2>/dev/null; then
            return 0
        fi
        sleep "$interval"
    done

    return 1
}

terminate_parent() {
    local ppid=$1
    local service=$2

    if ! is_numeric "$ppid"; then
        log_warn "skip parent not numeric" ppid="$ppid"
        return 1
    fi

    if [[ "$ppid" -lt 2 ]]; then
        if [[ "$ppid" -eq 1 ]]; then
            log_warn "skip parent ppid=1" ppid="$ppid"
        else
            log_warn "skip parent ppid<2" ppid="$ppid"
        fi
        return 1
    fi

    if ! kill -0 "$ppid" 2>/dev/null; then
        log_warn "skip parent already exited" ppid="$ppid"
        return 1
    fi

    if kill -TERM "$ppid" 2>/dev/null; then
        log_info "signal sent" signal="TERM" ppid="$ppid"
    else
        if kill -0 "$ppid" 2>/dev/null; then
            log_error "unable to send signal" signal="TERM" ppid="$ppid"
            return 1
        fi
        log_warn "skip parent already exited" ppid="$ppid"
        return 1
    fi

    if wait_for_exit "$ppid"; then
        log_info "parent terminated" ppid="$ppid"
    else
        log_warn "wait timeout reached" ppid="$ppid" wait_seconds="$WAIT_SECONDS"
        if [[ "$FORCE" -eq 1 ]]; then
            if kill -KILL "$ppid" 2>/dev/null; then
                log_warn "signal sent" signal="KILL" ppid="$ppid"
            else
                if kill -0 "$ppid" 2>/dev/null; then
                    log_error "unable to send signal" signal="KILL" ppid="$ppid"
                    return 1
                fi
                log_warn "skip parent already exited" ppid="$ppid"
                return 1
            fi

            if kill -0 "$ppid" 2>/dev/null; then
                log_error "parent still alive after KILL" ppid="$ppid"
                return 1
            fi
            log_info "parent terminated" ppid="$ppid"
        else
            log_error "parent still alive after TERM" ppid="$ppid"
            return 1
        fi
    fi

    if parent_has_zombies "$ppid"; then
        log_error "parent still has zombies" ppid="$ppid"
        return 1
    fi

    if [[ "$service" != "none" ]]; then
        log_info "service restart attempt" service="$service" ppid="$ppid"
        if systemctl restart "$service" 2>/dev/null; then
            log_info "service restarted" service="$service"
        else
            log_warn "service restart failed" service="$service"
        fi
    fi

    return 0
}

process_parents() {
    local failures=0
    local ppid service

    for ppid in "${PARENTS[@]}"; do
        service=${PARENT_SERVICE[$ppid]-}
        log_info "processing parent" ppid="$ppid" service="$service"
        if ! terminate_parent "$ppid" "$service"; then
            failures=$((failures + 1))
        fi
    done

    if [[ "$failures" -gt 0 ]]; then
        return 2
    fi

    return 0
}

cmd_list() {
    collect_zombies

    local count=${#ZOMBIES[@]}
    log_info "zombie detection" mode="list" count="$count"
    if [[ "$count" -eq 0 ]]; then
        echo "${OK_SYMBOL} Keine Zombie-Prozesse aktiv"
        return 0
    fi

    log_info "zombies found" count="$count"
    print_zombies
    if [[ "$OUTPUT_TTY" -eq 1 ]]; then
        echo
    fi

    return 2
}

cmd_auto() {
    collect_zombies
    collect_parents

    local count=${#ZOMBIES[@]}
    log_info "zombie detection" mode="auto" count="$count"
    if [[ "$count" -eq 0 ]]; then
        echo "${OK_SYMBOL} Keine Zombie-Prozesse aktiv"
        return 0
    fi

    log_info "zombies found" count="$count"
    print_zombies
    if [[ "$OUTPUT_TTY" -eq 1 ]]; then
        echo
    fi

    process_parents
}

cleanup_terminal() {
    if [[ -t 0 ]]; then
        stty echo 2>/dev/null || true
    fi
    if [[ -t 1 ]]; then
        printf '\n'
    fi
}

cmd_interactive() {
    trap cleanup_terminal EXIT INT TERM

    while true; do
        collect_zombies
        collect_parents

        local count=${#ZOMBIES[@]}
        log_info "zombie detection" mode="interactive" count="$count"
        if [[ "$count" -eq 0 ]]; then
            echo "${OK_SYMBOL} Keine Zombie-Prozesse aktiv"
            return 0
        fi

        log_info "zombies found" count="$count"
        print_zombies
        echo

        echo "Optionen:"
        echo "  r) Neu laden"
        echo "  a) Alle Parents terminieren"
        echo "  i) Einzeln bearbeiten"
        echo "  q) Beenden"

        local choice
        if ! read -r choice; then
            echo "${FAIL_SYMBOL} Keine Eingabe erhalten"
            return 1
        fi

        case "${choice,,}" in
            r)
                continue
                ;;
            a)
                local status=0
                process_parents || status=$?
                if [[ "$status" -eq 1 ]]; then
                    return 1
                fi
                if [[ "$status" -eq 2 ]]; then
                    echo "${WARN_SYMBOL} Aktion nicht vollst√§ndig. Neu laden mit r."
                else
                    echo "${INFO_SYMBOL} Aktion abgeschlossen. Neu laden mit r."
                fi
                ;;
            i)
                local index=1
                for entry in "${ZOMBIES[@]}"; do
                    IFS=, read -r pid ppid _state cmd service <<<"$entry"
                    echo "$index: PID $pid <- PPID $ppid ($cmd)"
                    index=$((index + 1))
                done
                local num
                if ! read -r num; then
                    echo "${FAIL_SYMBOL} Keine Auswahl erhalten"
                    return 1
                fi
                if [[ ! "$num" =~ ^[0-9]+$ || "$num" -lt 1 || "$num" -gt "$count" ]]; then
                    echo "${FAIL_SYMBOL} Ung√ºltig"
                    return 1
                fi
                local zombie_line=${ZOMBIES[$((num - 1))]}
                IFS=, read -r pid ppid _state cmd service <<<"$zombie_line"
                echo "${ZOMBIE_SYMBOL} Zombie $pid -> kill $ppid"
                if [[ "$FORCE" -ne 1 ]]; then
                    local confirm
                    echo "Bitte best√§tigen (y/N):"
                    if ! read -r confirm; then
                        echo "${FAIL_SYMBOL} Keine Best√§tigung erhalten"
                        return 1
                    fi
                    if [[ ! "$confirm" =~ [Yy] ]]; then
                        echo "${INFO_SYMBOL} Abgebrochen ($count Zombies)"
                        continue
                    fi
                fi
                if ! terminate_parent "$ppid" "$service"; then
                    echo "${WARN_SYMBOL} Aktion nicht vollst√§ndig"
                else
                    echo "${OK_SYMBOL} Aktion abgeschlossen"
                fi
                ;;
            q)
                echo "${INFO_SYMBOL} Abgebrochen ($count Zombies)"
                log_info "user quit" mode="interactive" count="$count"
                return 2
                ;;
            *)
                echo "${FAIL_SYMBOL} Ung√ºltig"
                log_warn "invalid menu selection" input="$choice"
                ;;
        esac
    done
}

cmd_watch() {
    trap 'echo; echo "√úberwachung beendet"; exit 0' INT TERM

    while true; do
        if cmd_list; then
            :
        else
            local status=$?
            if [[ "$status" -eq 1 ]]; then
                return 1
            fi
        fi
        sleep "$WATCH_INTERVAL"
    done
}

main() {
    parse_args "$@"
    setup_output_mode
    log_init
    log_info "checkzombies start" mode="$MODE" force="$FORCE" watch_interval="$WATCH_INTERVAL" log_level="$LOG_LEVEL"

    case "$MODE" in
        list)
            cmd_list
            ;;
        auto)
            cmd_auto
            ;;
        watch)
            cmd_watch
            ;;
        interactive)
            cmd_interactive
            ;;
        *)
            echo "Error: unknown mode $MODE" >&2
            return 1
            ;;
    esac
}

main "$@"
